<DOCTYPE html>
<html>
<head>
	<title>sky material build</title>

	<script src="../bower_components/jquery/dist/jquery.min.js"></script>
	<script src="../bower_components/threejs/build/three.min.js"></script>
	<script src="./perlin.js"></script>
	<script>
		var renderer = null,
				scene = null,
				camera = null;

		var ambientLight = null;
		var ambientCol = [0,0,0];
		var directionalLight1 = null;
		var directionalLight2 = null;
		var directionalLight3 = null;

		const subdivisions = 4;

		var sky1 = null;
		var sky1Radius = 20;
		var sky1Orig = [];
		var sky2 = null;
		var sky2Radius = 500;
		var sky2Orig = [];
		var sky3 = null;
		var sky3Radius = 2000;
		var sky3Orig = [];

		var start = Date.now();
		var time;

		var FOV = 45;

		var whichEffect = 0;

		$(document).ready(function() {

			// RENDERER, DOM, CAMERA -------------------------------------------

			var container = document.getElementById("container");
			renderer = new THREE.WebGLRenderer( { antialias : true } );
			renderer.setSize(container.offsetWidth, container.offsetHeight);
			container.appendChild(renderer.domElement);

			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera(FOV, container.offsetWidth/container.offsetHeight, 1, 4000);
			camera.position.set(0,0,200);

			// TIME SETUP -------------------------------------------

			time = Date.now() - start;

			// LIGHTS -------------------------------------------

			setUpLights();

			// MESHES -------------------------------------------

			var skyTexture = new THREE.TextureLoader().load( './images/skySphere1.jpg' );
			var skyMaterial = new THREE.MeshLambertMaterial( { map: skyTexture, side: THREE.DoubleSide } );

			sky1 = new THREE.Mesh( new THREE.IcosahedronGeometry( sky1Radius, subdivisions ), skyMaterial);
			sky1.position.set(0, 0, 0);
			explodeModifier(sky1.geometry);
			scene.add(sky1);

			var skyMaterial2 = new THREE.MeshLambertMaterial( { map: skyTexture, side: THREE.DoubleSide} );
			sky2 = new THREE.Mesh( new THREE.IcosahedronGeometry( sky2Radius, subdivisions ), skyMaterial2);
			explodeModifier(sky2.geometry);
			scene.add( sky2 );

			sky1Orig = getAllStartingPoints(sky1);
			sky2Orig = getAllStartingPoints(sky2);

			// SET UP EVENTS -------------------------------------------

			document.addEventListener('click', onDocumentMouseDown, false);
			window.addEventListener('resize', onWindowResize, false);

			run();
		});


		// MAIN LOOP

		function run() {
    	animate();
			renderer.render(scene, camera);
			requestAnimationFrame(run);
		}

		function animate() {
			time = Date.now() - start;
			updateLights();
			sky1.rotation.x += 0.0001;
    	sky1.rotation.y += 0.0002;

    	sky2.rotation.x += 0.00002;
    	sky2.rotation.y += 0.00001;

    	switch (whichEffect) {
    		case 0:
    			// flatsplode(sky1);
    			// implode(sky2);
    			asplode(sky1, sky1Orig);
    			// randomizeVertices(sky1);
    			break;
    		case 1:
    			lerpToResetVerts(sky1, sky1Orig);
    			break;
    		case 2:
    			moveToStartPoints(sky1, sky1Orig);
    			break;
    	}
    	
		}

		function onDocumentMouseDown(event) {
			whichEffect = (whichEffect+1) % 3;
		}

		function setUpLights() {
			ambientCol[0] = Math.floor(152+(Math.sin(time * 0.0001) * 152));
			ambientCol[1] = Math.floor(152+(Math.sin(time * 0.0001) * 152));
			ambientCol[2] = Math.floor(152+(Math.sin(time * 0.0001) * 152));
			// var ambientCol = new THREE.Color("rgb(255, 0, 0)");
			ambientLight = new THREE.AmbientLight();
			ambientLight.color.setStyle('rgb('+ambientCol[0]+','+ambientCol[1]+','+ambientCol[2]+')');
			scene.add(ambientLight);

			directionalLight1 = new THREE.DirectionalLight('rgb(100,50,50)', 1.0);
			directionalLight1.position.set(Math.sin(time*0.000051) * 2, Math.cos(time*0.000053) + Math.sin(time*0.00051)* 2, Math.sin(time*0.001) * 2);
			scene.add(directionalLight1);

			directionalLight2 = new THREE.DirectionalLight('rgb(130,100,50)', 1.0);
			directionalLight2.position.set(Math.cos(time*0.00013) + Math.sin(time*0.0011)* 2, Math.sin(time*0.00011) * 2, Math.sin(time*0.001) * 2);
			scene.add(directionalLight2);

			directionalLight3 = new THREE.DirectionalLight('rgb(40,40,70)', 1.0);
			directionalLight3.position.set(Math.sin(time*0.0001) * 2, Math.sin(time*0.0005) * 2, Math.cos(time*0.0003) + Math.sin(time*0.001)* 2);
		}

	

		function updateLights() {
			ambientCol[0] = Math.floor(152+(Math.sin(time * 0.0001) * 152));
			ambientCol[1] = Math.floor(152+(Math.sin(time * 0.0001) * 152));
			ambientCol[2] = Math.floor(152+(Math.sin(time * 0.0001) * 152));
			ambientLight.color.setStyle('rgb('+ambientCol[0]+','+ambientCol[1]+','+ambientCol[2]+')');

			directionalLight1.position.set(Math.sin(time*0.000051) * 2, Math.cos(time*0.000053) + Math.sin(time*0.00051)* 2, Math.sin(time*0.001) * 2);

			directionalLight2.position.set(Math.cos(time*0.00013) + Math.sin(time*0.0011)* 2, Math.sin(time*0.00011) * 2, Math.sin(time*0.001) * 2);

			directionalLight3.position.set(Math.sin(time*0.0001) * 2, Math.sin(time*0.0005) * 2, Math.cos(time*0.0003) + Math.sin(time*0.001)* 2);
		}

		// DEFORMATION FUNCTIONS

		function implode(mesh) {
			var xoff = 0;
			mesh.geometry.faces.forEach((face, i) => {
				var a = (noise.simplex3(xoff, time * 0.0005, time * 0.0001)) - 0.5;

				var modFace = face.normal.clone();
				modFace.multiplyScalar(a*0.1);
				mesh.geometry.vertices[face.a].add(modFace);
				mesh.geometry.vertices[face.b].add(modFace);
				mesh.geometry.vertices[face.c].add(modFace);

				xoff += 0.1;
			});
			mesh.geometry.verticesNeedUpdate = true;
		}

		function flatsplode(mesh) {
			var xoff = 0;
			mesh.geometry.faces.forEach((face, i) => {
				var a = 0.5 + 0.5 * (noise.simplex2(xoff, time * 0.0005));
				
				var modFace = face.normal.clone();
				modFace.multiplyScalar(a*0.1);
				mesh.geometry.vertices[face.a].add(modFace);
				mesh.geometry.vertices[face.b].add(modFace);
				mesh.geometry.vertices[face.c].add(modFace);

				xoff += 0.1;
			});
			mesh.geometry.verticesNeedUpdate = true;
		}

		function asplode(mesh, originalVerts) {
			mesh.geometry.faces.forEach((face, i) => {
				var noiseMagA = noise.simplex3(face.a, originalVerts.vertices[face.a].y, time*0.001) * 0.05;
				var noiseMagB = noise.simplex3(face.b, originalVerts.vertices[face.b].y, time*0.001) * 0.05;
				var noiseMagC = noise.simplex3(face.c, originalVerts.vertices[face.c].y, time*0.001) * 0.05;

				// var noiseMagA = noise.simplex2(face.a, mesh.geometry.vertices[face.a].y, time*0.001) * 0.11;
				// var noiseMagB = noise.simplex2(face.b, mesh.geometry.vertices[face.b].y, time*0.001) * 0.11;
				// var noiseMagC = noise.simplex2(face.c, mesh.geometry.vertices[face.c].y, time*0.001) * 0.11;

				// var noiseMagA = noise.simplex2(face.a, time*0.001) * 0.11;
				// var noiseMagB = noise.simplex2(face.b, time*0.001) * 0.11;
				// var noiseMagC = noise.simplex2(face.c, time*0.001) * 0.11;

				var modVertA = face.normal.clone();//face.vertexNormals[0].clone();
				var modVertB = face.normal.clone();//face.vertexNormals[1].clone();
				var modVertC = face.normal.clone();//face.vertexNormals[2].clone(); 

				modVertA.multiplyScalar(noiseMagA);
				modVertB.multiplyScalar(noiseMagB);
				modVertC.multiplyScalar(noiseMagC);

				mesh.geometry.vertices[face.a].add(modVertA);
				mesh.geometry.vertices[face.b].add(modVertB);
				mesh.geometry.vertices[face.c].add(modVertC);
			});
			mesh.geometry.verticesNeedUpdate = true;
		}



		function lerpToResetVerts(mesh, originalVerts) {
			mesh.geometry.vertices.forEach((vertex, i) => {
				var d = vertex.distanceTo(originalVerts.vertices[i]);
				if (d > 0.0001) {
					vertex.lerp(originalVerts.vertices[i], 0.01);
				} else {
					vertex = originalVerts.vertices[i].clone();
				}
			});
			mesh.geometry.verticesNeedUpdate = true;
		}

		// moves all vertices by random amount
		function randomizeVertices(mesh) {
			mesh.geometry.vertices.forEach((vertex, i) => {
				vertex.x += Math.random() * 5 - 2.5;
				vertex.y += Math.random() * 5 - 2.5;
				vertex.z += Math.random() * 5 - 2.5;
			});
			mesh.geometry.verticesNeedUpdate = true;
		}

		// UTILITY FUNCTIONS ------------------------------------------------

		function scaleMeshAndOrig(x, y, z, mesh, originalVerts) {
			mesh.geometry.scale(x,y,z);
			originalVerts.scale(x,y,z);
		}

		function getAllStartingPoints(mesh) {
			var originalVerts = mesh.geometry.clone();
			return originalVerts;
		}

		function moveToStartPoints(mesh, originalVerts) {
			mesh.geometry = originalVerts.clone();
		}

		function onWindowResize() {
			renderer.setSize(window.innerWidth, window.innerHeight);
			camera.projectionMatrix.makePerspective(FOV, window.innerWidth/window.innerHeight, 1, 10000);
		}

		function explodeModifier(geometry) {
			var vertices = [];

			for (var i = 0, il = geometry.faces.length; i < il; i++) {
				var n = vertices.length;
				var face = geometry.faces[i];
				var a = face.a;
				var b = face.b;
				var c = face.c;
				var va = geometry.vertices[a];
				var vb = geometry.vertices[b];
				var vc = geometry.vertices[c];
				vertices.push(va.clone());
				vertices.push(vb.clone());
				vertices.push(vc.clone());
				face.a = n;
				face.b = n+1;
				face.c = n+2;
			}

			geometry.vertices = vertices;
		}

		// TEST FUNCTIONS ------------------------------------------------
		

	</script>
</head>

<body>
	<div id="container" style="width:100%; height:100%; overflow:hidden; position:absolute; background-color: #000000"></div>
</body>

</html>